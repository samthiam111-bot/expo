#!/usr/bin/env node

import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

import { commandRunner, getArgs, addWatchFlagIfNeeded } from '../utils/commandUtils.js';

const dirname = path.dirname(fileURLToPath(import.meta.url));

const EXTRA_MODULE_BUILD_TARGETS = ['plugin', 'cli', 'utils', 'scripts'];

let args = getArgs();

// If the command is used like `yarn build plugin`, set the --build option to point to plugin/tsconfig.json
if (EXTRA_MODULE_BUILD_TARGETS.includes(args[0])) {
  const target = args[0];
  const targetDir = path.join(process.cwd(), args[0]);
  if (fs.existsSync(path.join(targetDir, 'tsconfig.json'))) {
    // Push the rest of the arguments minus the `plugin` arg
    const restArgs = args.slice(1);
    args = ['--build', targetDir, ...restArgs];
  } else {
    console.log(`tsconfig.json not found in ${target}, skipping build for ${target}`);
    process.exit(0);
  }
}

// Packages that need multiple output formats (e.g. @expo/devtools emits both ESM and CJS)
// use tsc project references with a solution-style tsconfig.json. When references are
// present, switch to `tsc --build .` so all referenced projects compile in a single pass
// (including --watch mode).
if (!args.includes('--build')) {
  const tsconfigPath = path.join(process.cwd(), 'tsconfig.json');
  if (fs.existsSync(tsconfigPath)) {
    try {
      const tsconfig = JSON.parse(fs.readFileSync(tsconfigPath, 'utf8'));
      if (Array.isArray(tsconfig.references) && tsconfig.references.length > 0) {
        args.unshift('--build', '.');
      }
    } catch {}
  }
}

args = addWatchFlagIfNeeded(args);
await commandRunner(path.join(dirname, 'expo-module-tsc'), args);
