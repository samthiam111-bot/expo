import spawnAsync from '@expo/spawn-async';
import chalk from 'chalk';
import { Command } from 'commander';
import ejs from 'ejs';
import fs from 'node:fs';
import os from 'node:os';
import path from 'node:path';
import prompts from 'prompts';
import validateNpmPackage from 'validate-npm-package-name';

import { createExampleApp } from './createExampleApp';
import {
  installDependencies,
  formatRunCommand,
  resolvePackageManager,
  type PackageManagerName,
} from './packageManager';
import {
  getLocalFolderNamePrompt,
  getLocalSubstitutionDataPrompts,
  getSlugPrompt,
  getSubstitutionDataPrompts,
} from './prompts';
import { eventCreateExpoModule, getTelemetryClient, logEventAsync } from './telemetry';
import type { CommandOptions, LocalSubstitutionData, SubstitutionData } from './types';
import { env } from './utils/env';
import { findGitHubEmail, findMyName } from './utils/git';
import { findGitHubUserFromEmail, guessRepoUrl } from './utils/github';
import { newStep } from './utils/ora';
import { extractLocalTarball } from './utils/tar';

const debug = require('debug')('create-expo-module:main') as typeof console.log;
const packageJson = require('../package.json');

// `yarn run` may change the current working dir, then we should use `INIT_CWD` env.
const CWD = process.env.INIT_CWD || process.cwd();

// Ignore some paths. Especially `package.json` as it is rendered
// from `$package.json` file instead of the original one.
const IGNORES_PATHS = [
  '.DS_Store',
  'build',
  'node_modules',
  'package.json',
  '.npmignore',
  '.gitignore',
];

// Url to the documentation on Expo Modules
const DOCS_URL = 'https://docs.expo.dev/modules';

const FYI_LOCAL_DIR = 'https://expo.fyi/expo-module-local-autolinking.md';

/**
 * Determines if we're in an interactive environment.
 * Non-interactive when: CI=1/true or non-TTY stdin.
 */
function isInteractive(): boolean {
  // Check for CI environment
  const ci = process.env.CI;
  if (ci === '1' || ci === 'true' || ci?.toLowerCase() === 'true') {
    return false;
  }
  // Check for TTY
  if (!process.stdin.isTTY) {
    return false;
  }
  return true;
}

/**
 * Converts a slug to a native module name (PascalCase).
 */
function slugToModuleName(slug: string): string {
  return slug
    .replace(/^@/, '')
    .replace(/^./, (match) => match.toUpperCase())
    .replace(/\W+(\w)/g, (_, p1) => p1.toUpperCase());
}

/**
 * Converts a slug to an Android package name.
 */
function slugToAndroidPackage(slug: string): string {
  const namespace = slug
    .replace(/\W/g, '')
    .replace(/^(expo|reactnative)/, '')
    .toLowerCase();
  return `expo.modules.${namespace}`;
}

async function getCorrectLocalDirectory(targetOrSlug: string) {
  let packageJsonPath: string | null = null;
  for (let dir = CWD; path.dirname(dir) !== dir; dir = path.dirname(dir)) {
    const file = path.resolve(dir, 'package.json');
    if (fs.existsSync(file)) {
      packageJsonPath = file;
      break;
    }
  }
  if (!packageJsonPath) {
    console.log(
      chalk.red.bold(
        '⚠️ This command should be run inside your Expo project when run with the --local flag.'
      )
    );
    console.log(
      chalk.red(
        'For native modules to autolink correctly, you need to place them in the `modules` directory in the root of the project.'
      )
    );
    return null;
  }
  return path.join(packageJsonPath, '..', 'modules', targetOrSlug);
}

/**
 * The main function of the command.
 *
 * @param target Path to the directory where to create the module. Defaults to current working dir.
 * @param options An options object for `commander`.
 */
async function main(target: string | undefined, options: CommandOptions) {
  const interactive = isInteractive();
  if (!interactive) {
    debug('Running in non-interactive mode');
  }

  if (options.local) {
    console.log();
    console.log(
      `${chalk.gray('The local module will be created in the ')}${chalk.gray.bold.italic(
        'modules'
      )} ${chalk.gray('directory in the root of your project. Learn more: ')}${chalk.gray.bold(
        FYI_LOCAL_DIR
      )}`
    );
    console.log();
  }
  const slug = await askForPackageSlugAsync(target, options.local, options);
  const targetDir = options.local
    ? await getCorrectLocalDirectory(target || slug)
    : path.join(CWD, target || slug);

  if (!targetDir) {
    return;
  }
  await fs.promises.mkdir(targetDir, { recursive: true });
  await confirmTargetDirAsync(targetDir, options);

  options.target = targetDir;

  const data = await askForSubstitutionDataAsync(slug, options.local, options);

  // Make one line break between prompts and progress logs
  console.log();

  const packageManager = resolvePackageManager();
  const packagePath = options.source
    ? path.join(CWD, options.source)
    : await downloadPackageAsync(targetDir, options.local);

  await logEventAsync(eventCreateExpoModule(packageManager, options));

  await newStep('Creating the module from template files', async (step) => {
    await createModuleFromTemplate(packagePath, targetDir, data);
    step.succeed('Created the module from template files');
  });
  if (!options.local) {
    await newStep('Installing module dependencies', async (step) => {
      await installDependencies(packageManager, targetDir);
      step.succeed('Installed module dependencies');
    });
    await newStep('Compiling TypeScript files', async (step) => {
      await spawnAsync(packageManager, ['run', 'build'], {
        cwd: targetDir,
        stdio: 'ignore',
      });
      step.succeed('Compiled TypeScript files');
    });
  }

  if (!options.source) {
    // Files in the downloaded tarball are wrapped in `package` dir.
    // We should remove it after all.
    await fs.promises.rm(packagePath, { recursive: true, force: true });
  }
  if (!options.local && data.type !== 'local') {
    if (!options.withReadme) {
      await fs.promises.rm(path.join(targetDir, 'README.md'), { force: true });
    }
    if (!options.withChangelog) {
      await fs.promises.rm(path.join(targetDir, 'CHANGELOG.md'), { force: true });
    }
    if (options.example) {
      // Create "example" folder
      await createExampleApp(data, targetDir, packageManager);
    }

    await newStep('Creating an empty Git repository', async (step) => {
      try {
        const result = await createGitRepositoryAsync(targetDir);
        if (result) {
          step.succeed('Created an empty Git repository');
        } else if (result === null) {
          step.succeed('Skipped creating an empty Git repository, already within a Git repository');
        } else if (result === false) {
          step.warn(
            'Could not create an empty Git repository, see debug logs with EXPO_DEBUG=true'
          );
        }
      } catch (error: any) {
        step.fail(error.toString());
      }
    });
  }

  console.log();
  if (options.local) {
    console.log(`✅ Successfully created Expo module in ${chalk.bold.italic(`modules/${slug}`)}`);
    printFurtherLocalInstructions(slug, data.project.moduleName);
  } else {
    console.log('✅ Successfully created Expo module');
    printFurtherInstructions(targetDir, packageManager, options.example);
  }
}

/**
 * Recursively scans for the files within the directory. Returned paths are relative to the `root` path.
 */
async function getFilesAsync(root: string, dir: string | null = null): Promise<string[]> {
  const files: string[] = [];
  const baseDir = dir ? path.join(root, dir) : root;

  for (const file of await fs.promises.readdir(baseDir)) {
    const relativePath = dir ? path.join(dir, file) : file;

    if (IGNORES_PATHS.includes(relativePath) || IGNORES_PATHS.includes(file)) {
      continue;
    }

    const fullPath = path.join(baseDir, file);
    const stat = await fs.promises.lstat(fullPath);
    if (stat.isDirectory()) {
      files.push(...(await getFilesAsync(root, relativePath)));
    } else {
      files.push(relativePath);
    }
  }
  return files;
}

/**
 * Downloads a package tarball using `npm pack` and returns the filename.
 */
async function npmPackAsync(packageName: string, cwd: string): Promise<string> {
  const npm = process.platform === 'win32' ? 'npm.cmd' : 'npm';
  const cmd = ['pack', packageName, '--json'];
  const cmdString = `${npm} ${cmd.join(' ')}`;
  debug('Run:', cmdString, `(cwd: ${cwd})`);

  let results: string;
  try {
    results = (await spawnAsync(npm, cmd, { cwd })).stdout?.trim();
  } catch (error: any) {
    if (error?.stderr?.match(/npm ERR! code E404/)) {
      const pkg =
        error.stderr.match(/npm ERR! 404\s+'(.*)' is not in this registry\./)?.[1] ?? error.stderr;
      throw new Error(`NPM package not found: ` + pkg);
    }
    throw error;
  }

  if (!results) {
    throw new Error(`No output from "${cmdString}"`);
  }

  try {
    const json = JSON.parse(results);
    if (!Array.isArray(json) || !json[0]?.filename) {
      throw new Error(`Invalid response from npm: ${results}`);
    }
    return json[0].filename;
  } catch (error: any) {
    throw new Error(
      `Could not parse JSON returned from "${cmdString}".\n\n${results}\n\nError: ${error.message}`
    );
  }
}

/**
 * Gets expo SDK version major from the local package.json.
 */
async function getLocalSdkMajorVersion(): Promise<string | null> {
  const path = require.resolve('expo/package.json', { paths: [process.cwd()] });
  if (!path) {
    return null;
  }
  const { version } = require(path) ?? {};
  return version?.split('.')[0] ?? null;
}

/**
 * Selects correct version of the template based on the SDK version for local modules and EXPO_BETA flag.
 */
async function getTemplateVersion(isLocal: boolean) {
  if (env.EXPO_BETA) {
    return 'next';
  }
  if (!isLocal) {
    return 'latest';
  }
  try {
    const sdkVersionMajor = await getLocalSdkMajorVersion();
    return sdkVersionMajor ? `sdk-${sdkVersionMajor}` : 'latest';
  } catch {
    console.log();
    console.warn(
      chalk.yellow(
        "Couldn't determine the SDK version from the local project, using `latest` as the template version."
      )
    );
    return 'latest';
  }
}

/**
 * Downloads the template from NPM registry.
 */
async function downloadPackageAsync(targetDir: string, isLocal = false): Promise<string> {
  return await newStep('Downloading module template from npm', async (step) => {
    const templateVersion = await getTemplateVersion(isLocal);
    const packageName = isLocal ? 'expo-module-template-local' : 'expo-module-template';
    const tmpDir = path.join(os.tmpdir(), '.create-expo-module');

    await fs.promises.mkdir(tmpDir, { recursive: true });

    let filename: string;
    try {
      filename = await npmPackAsync(`${packageName}@${templateVersion}`, tmpDir);
    } catch {
      console.log();
      console.warn(
        chalk.yellow(
          "Couldn't download the versioned template from npm, falling back to the latest version."
        )
      );
      filename = await npmPackAsync(`${packageName}@latest`, tmpDir);
    }

    await extractLocalTarball({
      filePath: path.join(tmpDir, filename),
      dir: targetDir,
    });

    await fs.promises.rm(tmpDir, { recursive: true, force: true });

    step.succeed('Downloaded module template from npm registry.');

    return path.join(targetDir, 'package');
  });
}

function handleSuffix(name: string, suffix: string): string {
  if (name.endsWith(suffix)) {
    return name;
  }
  return `${name}${suffix}`;
}

/**
 * Creates the module based on the `ejs` template (e.g. `expo-module-template` package).
 */
async function createModuleFromTemplate(
  templatePath: string,
  targetPath: string,
  data: SubstitutionData | LocalSubstitutionData
) {
  const files = await getFilesAsync(templatePath);

  // Iterate through all template files.
  for (const file of files) {
    const renderedRelativePath = ejs.render(file.replace(/^\$/, ''), data, {
      openDelimiter: '{',
      closeDelimiter: '}',
      escape: (value: string) => value.replace(/\./g, path.sep),
    });
    const fromPath = path.join(templatePath, file);
    const toPath = path.join(targetPath, renderedRelativePath);
    const template = await fs.promises.readFile(fromPath, 'utf8');
    const renderedContent = ejs.render(template, data);

    if (!fs.existsSync(path.dirname(toPath))) {
      await fs.promises.mkdir(path.dirname(toPath), { recursive: true });
    }
    await fs.promises.writeFile(toPath, renderedContent, 'utf8');
  }
}

async function createGitRepositoryAsync(targetDir: string) {
  // Check if we are inside a git repository already
  try {
    await spawnAsync('git', ['rev-parse', '--is-inside-work-tree'], {
      stdio: 'ignore',
      cwd: targetDir,
    });
    debug(chalk.dim('New project is already inside of a Git repository, skipping `git init`.'));
    return null;
  } catch (e: any) {
    if (e.errno === 'ENOENT') {
      debug(chalk.dim('Unable to initialize Git repo. `git` not in $PATH.'));
      return false;
    }
  }

  // Create a new git repository
  await spawnAsync('git', ['init'], { stdio: 'ignore', cwd: targetDir });
  await spawnAsync('git', ['add', '-A'], { stdio: 'ignore', cwd: targetDir });

  const commitMsg = `Initial commit\n\nGenerated by ${packageJson.name} ${packageJson.version}.`;
  await spawnAsync('git', ['commit', '-m', commitMsg], {
    stdio: 'ignore',
    cwd: targetDir,
  });

  debug(chalk.dim('Initialized a Git repository.'));
  return true;
}

/**
 * Asks the user for the package slug (npm package name).
 * In non-interactive mode, uses the target path or 'my-module' as default.
 */
async function askForPackageSlugAsync(
  customTargetPath: string | undefined,
  isLocal: boolean,
  options: CommandOptions
): Promise<string> {
  const interactive = isInteractive();

  // In non-interactive mode, derive slug from target path or use default
  if (!interactive) {
    const targetBasename = customTargetPath && path.basename(customTargetPath);
    const slug =
      targetBasename && validateNpmPackage(targetBasename).validForNewPackages
        ? targetBasename
        : 'my-module';
    debug(`Non-interactive mode: using slug "${slug}"`);
    return slug;
  }

  const { slug } = await prompts(
    (isLocal ? getLocalFolderNamePrompt : getSlugPrompt)(customTargetPath),
    {
      onCancel: () => process.exit(0),
    }
  );
  return slug;
}

/**
 * Asks the user for some data necessary to render the template.
 * Some values may already be provided by command options, the prompt is skipped in that case.
 * In non-interactive mode, uses defaults or CLI-provided values.
 */
async function askForSubstitutionDataAsync(
  slug: string,
  isLocal: boolean,
  options: CommandOptions
): Promise<SubstitutionData | LocalSubstitutionData> {
  const interactive = isInteractive();

  // Non-interactive mode: use CLI options and defaults
  if (!interactive) {
    return getSubstitutionDataFromOptions(slug, isLocal, options);
  }

  // Interactive mode: prompt for values, but skip prompts for CLI-provided values
  const promptQueries = await (
    isLocal ? getLocalSubstitutionDataPrompts : getSubstitutionDataPrompts
  )(slug);

  // Filter out prompts for values already provided via CLI
  const filteredPrompts = promptQueries.filter((prompt) => {
    const name = prompt.name as string;
    const cliValue = getCliValueForPrompt(name, options);
    return cliValue === undefined;
  });

  // Stop the process when the user cancels/exits the prompt.
  const onCancel = () => {
    process.exit(0);
  };

  // Get values from prompts
  const promptedValues =
    filteredPrompts.length > 0 ? await prompts(filteredPrompts, { onCancel }) : {};

  // Merge CLI-provided values with prompted values
  const name = options.name ?? promptedValues.name ?? slugToModuleName(slug);
  const projectPackage = options.package ?? promptedValues.package ?? slugToAndroidPackage(slug);

  if (isLocal) {
    return {
      project: {
        slug,
        name,
        package: projectPackage,
        moduleName: handleSuffix(name, 'Module'),
        viewName: handleSuffix(name, 'View'),
      },
      type: 'local',
    };
  }

  const description = options.description ?? promptedValues.description ?? 'My new module';
  const authorName = options.authorName ?? promptedValues.authorName ?? (await findMyName()) ?? '';
  const authorEmail =
    options.authorEmail ?? promptedValues.authorEmail ?? (await findGitHubEmail()) ?? '';
  const authorUrl =
    options.authorUrl ??
    promptedValues.authorUrl ??
    (authorEmail ? ((await findGitHubUserFromEmail(authorEmail)) ?? '') : '');
  const repo = options.repo ?? promptedValues.repo ?? (await guessRepoUrl(authorUrl, slug)) ?? '';

  return {
    project: {
      slug,
      name,
      version: '0.1.0',
      description,
      package: projectPackage,
      moduleName: handleSuffix(name, 'Module'),
      viewName: handleSuffix(name, 'View'),
    },
    author: `${authorName} <${authorEmail}> (${authorUrl})`,
    license: 'MIT',
    repo,
    type: 'remote',
  };
}

/**
 * Gets the CLI value for a given prompt name.
 */
function getCliValueForPrompt(promptName: string, options: CommandOptions): string | undefined {
  switch (promptName) {
    case 'name':
      return options.name;
    case 'description':
      return options.description;
    case 'package':
      return options.package;
    case 'authorName':
      return options.authorName;
    case 'authorEmail':
      return options.authorEmail;
    case 'authorUrl':
      return options.authorUrl;
    case 'repo':
      return options.repo;
    default:
      return undefined;
  }
}

/**
 * Gets substitution data from CLI options and defaults (for non-interactive mode).
 */
async function getSubstitutionDataFromOptions(
  slug: string,
  isLocal: boolean,
  options: CommandOptions
): Promise<SubstitutionData | LocalSubstitutionData> {
  const name = options.name ?? slugToModuleName(slug);
  const projectPackage = options.package ?? slugToAndroidPackage(slug);

  debug(`Non-interactive mode: name="${name}", package="${projectPackage}"`);

  if (isLocal) {
    return {
      project: {
        slug,
        name,
        package: projectPackage,
        moduleName: handleSuffix(name, 'Module'),
        viewName: handleSuffix(name, 'View'),
      },
      type: 'local',
    };
  }

  // For remote modules, resolve author info
  const description = options.description ?? 'My new module';
  const authorName = options.authorName ?? (await findMyName()) ?? '';
  const authorEmail = options.authorEmail ?? (await findGitHubEmail()) ?? '';
  const authorUrl =
    options.authorUrl ?? (authorEmail ? ((await findGitHubUserFromEmail(authorEmail)) ?? '') : '');
  const repo = options.repo ?? (await guessRepoUrl(authorUrl, slug)) ?? '';

  debug(
    `Non-interactive mode: description="${description}", authorName="${authorName}", authorEmail="${authorEmail}", authorUrl="${authorUrl}", repo="${repo}"`
  );

  return {
    project: {
      slug,
      name,
      version: '0.1.0',
      description,
      package: projectPackage,
      moduleName: handleSuffix(name, 'Module'),
      viewName: handleSuffix(name, 'View'),
    },
    author: `${authorName} <${authorEmail}> (${authorUrl})`,
    license: 'MIT',
    repo,
    type: 'remote',
  };
}

/**
 * Checks whether the target directory is empty and if not, asks the user to confirm if he wants to continue.
 * In non-interactive mode, automatically continues (assumes intent to overwrite).
 */
async function confirmTargetDirAsync(targetDir: string, options: CommandOptions): Promise<void> {
  const files = await fs.promises.readdir(targetDir);
  if (files.length === 0) {
    return;
  }

  // In non-interactive mode, proceed automatically
  if (!isInteractive()) {
    debug(`Non-interactive mode: target directory "${targetDir}" is not empty, continuing anyway`);
    console.log(
      chalk.yellow(
        `Warning: Target directory ${chalk.magenta(targetDir)} is not empty, continuing anyway.`
      )
    );
    return;
  }

  const { shouldContinue } = await prompts(
    {
      type: 'confirm',
      name: 'shouldContinue',
      message: `The target directory ${chalk.magenta(
        targetDir
      )} is not empty, do you want to continue anyway?`,
      initial: true,
    },
    {
      onCancel: () => false,
    }
  );
  if (!shouldContinue) {
    process.exit(0);
  }
}

/**
 * Prints how the user can follow up once the script finishes creating the module.
 */
function printFurtherInstructions(
  targetDir: string,
  packageManager: PackageManagerName,
  includesExample: boolean
) {
  if (includesExample) {
    const commands = [
      `cd ${path.relative(CWD, targetDir)}`,
      formatRunCommand(packageManager, 'open:ios'),
      formatRunCommand(packageManager, 'open:android'),
    ];

    console.log();
    console.log(
      'To start developing your module, navigate to the directory and open Android and iOS projects of the example app'
    );
    commands.forEach((command) => console.log(chalk.gray('>'), chalk.bold(command)));
    console.log();
  }
  console.log(`Learn more on Expo Modules APIs: ${chalk.blue.bold(DOCS_URL)}`);
}

function printFurtherLocalInstructions(slug: string, name: string) {
  console.log();
  console.log(`You can now import this module inside your application.`);
  console.log(`For example, you can add this line to your App.tsx or App.js file:`);
  console.log(`${chalk.gray.italic(`import ${name} from './modules/${slug}';`)}`);
  console.log();
  console.log(`Learn more on Expo Modules APIs: ${chalk.blue.bold(DOCS_URL)}`);
  console.log(
    chalk.yellow(
      `Remember to re-build your native app (for example, with ${chalk.bold('npx expo run')}) when you make changes to the module. Native code changes are not reloaded with Fast Refresh.`
    )
  );
}

const program = new Command();

program
  .name(packageJson.name)
  .version(packageJson.version)
  .description(packageJson.description)
  .arguments('[path]')
  .option(
    '-s, --source <source_dir>',
    'Local path to the template. By default it downloads `expo-module-template` from NPM.'
  )
  .option('--with-readme', 'Whether to include README.md file.', false)
  .option('--with-changelog', 'Whether to include CHANGELOG.md file.', false)
  .option('--no-example', 'Whether to skip creating the example app.', false)
  .option(
    '--local',
    'Whether to create a local module in the current project, skipping installing node_modules and creating the example directory.',
    false
  )
  // Module configuration options (skip prompts when provided)
  .option('--name <name>', 'Native module name (e.g., MyModule).')
  .option('--description <description>', 'Module description.')
  .option('--package <package>', 'Android package name (e.g., expo.modules.mymodule).')
  .option('--author-name <name>', 'Author name for package.json.')
  .option('--author-email <email>', 'Author email for package.json.')
  .option('--author-url <url>', "URL to the author's profile (e.g., GitHub profile).")
  .option('--repo <url>', 'URL of the repository.')
  .action(main);

program
  .hook('postAction', async () => {
    await getTelemetryClient().flush?.();
  })
  .parse(process.argv);
